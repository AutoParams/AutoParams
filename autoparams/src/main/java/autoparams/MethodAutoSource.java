package autoparams;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.Proxy;

import org.junit.jupiter.params.provider.ArgumentsSource;
import org.junit.jupiter.params.provider.MethodSource;

/**
 * Annotation that provides test data from static factory methods, combining
 * JUnit 5's {@link MethodSource} with AutoParams' automatic parameter
 * generation.
 * <p>
 * This annotation allows you to specify a method that provides some test
 * arguments, while AutoParams automatically generates values for any remaining
 * parameters not covered by the method's return values.
 * </p>
 *
 * <p><b>Example:</b></p>
 * <p>
 * This example demonstrates how to use {@link MethodAutoSource} with a static
 * method that provides partial test data, with remaining parameters
 * automatically generated.
 * </p>
 * <pre>
 * &#64;ParameterizedTest
 * &#64;MethodAutoSource("testDataSource")
 * void testMethod(String name, BigDecimal priceAmount, UUID id) {
 *     // name and priceAmount are provided by the testDataSource method
 *     // id is automatically generated by AutoParams
 *     Product product = new Product(id, name, priceAmount);
 *     assertTrue(product.getName().startsWith("Product"));
 * }
 *
 * static Stream&lt;Arguments&gt; testDataSource() {
 *     return Stream.of(
 *         arguments("Product 1", new BigDecimal(500)),
 *         arguments("Product 2", new BigDecimal(10000))
 *     );
 * }
 * </pre>
 *
 * @see AutoSource
 * @see MethodAutoArgumentsProvider
 * @see MethodSource
 */
@Target({ ElementType.ANNOTATION_TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@ArgumentsSource(MethodAutoArgumentsProvider.class)
public @interface MethodAutoSource {

    /**
     * Specifies the name of the method to use as a source of arguments.
     * <p>
     * The method must be static and available in the test context. The method
     * naming should follow these conventions:
     * </p>
     *
     * <ul>
     *   <li>
     *     If the source method is in the same class as the test method, use the
     *     method name, for example: {@code "testDataSource"}
     *   </li>
     *   <li>
     *     If the source method is in a different class, use the fully qualified
     *     name, for example: {@code "com.example.TestClass#testDataSource"}
     *   </li>
     *   <li>
     *     Multiple method names can be specified, for example:
     *     {@code {"testDataSource1", "testDataSource2"}}
     *   </li>
     * </ul>
     *
     * <p>
     * If no method names are specified, JUnit will search for a method with the
     * same name as the test method but with no parameters.
     * </p>
     *
     * @return an array of method names
     * @see MethodSource#value
     */
    String[] value() default { "" };

    /**
     * Factory for creating dynamic proxy instances of {@link MethodAutoSource}.
     * <p>
     * This utility class provides a way to programmatically create
     * {@link MethodAutoSource} annotation instances at runtime, which is useful
     * when extending the functionality of {@link MethodAutoArgumentsProvider}.
     * </p>
     *
     * @see MethodAutoArgumentsProvider#accept(MethodAutoSource)
     */
    class ProxyFactory {

        /**
         * Creates a dynamic proxy instance of {@link MethodAutoSource} with the
         * specified method names.
         * <p>
         * This utility method enables programmatic creation of
         * {@link MethodAutoSource} annotation instances at runtime, which is
         * useful for extending functionality of
         * {@link MethodAutoArgumentsProvider}.
         * </p>
         *
         * @param value an array of method names to be used as argument sources
         * @return a proxy instance of the {@link MethodAutoSource} annotation
         * @see MethodAutoArgumentsProvider#accept(MethodAutoSource)
         * @see MethodSource
         */
        public static MethodAutoSource create(String[] value) {
            return (MethodAutoSource) Proxy.newProxyInstance(
                MethodAutoSource.class.getClassLoader(),
                new Class[] { MethodAutoSource.class },
                (proxy, method, args) -> {
                    switch (method.getName()) {
                        case "annotationType": return MethodAutoSource.class;
                        case "value": return value;
                        default: return method.getDefaultValue();
                    }
                }
            );
        }
    }
}
