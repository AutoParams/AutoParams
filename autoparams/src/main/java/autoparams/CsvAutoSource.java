package autoparams;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.Proxy;

import org.junit.jupiter.params.provider.ArgumentsSource;
import org.junit.jupiter.params.provider.CsvSource;

/**
 * Annotation that provides CSV format test data for parameterized tests,
 * combining JUnit 5's {@link CsvSource} with AutoParams' automatic parameter
 * generation.
 * <p>
 * This annotation allows you to define explicit values in CSV format while
 * AutoParams automatically generates values for any parameters not specified
 * in the CSV input.
 * </p>
 *
 * <p><b>Example:</b></p>
 * <p>
 * This example demonstrates how to use {@link CsvAutoSource} to provide
 * partial test data in CSV format, with remaining parameters automatically
 * generated.
 * </p>
 * <pre>
 * &#64;ParameterizedTest
 * &#64;CsvAutoSource({
 *     "Product 1, 500",
 *     "Product 2, 10000"
 * })
 * void testMethod(String name, BigDecimal priceAmount, UUID id) {
 *     // name and priceAmount are provided by CsvAutoSource
 *     // id is automatically generated by AutoParams
 *     Product product = new Product(id, name, priceAmount);
 *     assertTrue(product.getName().startsWith("Product"));
 * }
 * </pre>
 *
 * @see AutoSource
 * @see CsvAutoArgumentsProvider
 * @see CsvSource
 */
@Target({ ElementType.ANNOTATION_TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@ArgumentsSource(CsvAutoArgumentsProvider.class)
public @interface CsvAutoSource {

    /**
     * Provides CSV values to the test method, where each string represents a
     * row.
     * <p>
     * Each row in the CSV format represents a set of arguments for one test
     * invocation. AutoParams will automatically generate values for any
     * parameters not specified in the CSV data.
     * </p>
     *
     * @return an array of CSV rows
     * @see CsvSource#value
     */
    String[] value() default { };

    /**
     * Provides a text block containing CSV values, where each line represents a
     * row.
     * <p>
     * This is an alternative to {@link #value} that allows for more readable
     * multi-line CSV data using Java text blocks.
     * </p>
     *
     * @return a text block containing CSV values
     * @see CsvSource#textBlock
     */
    String textBlock() default "";

    /**
     * Determines whether CSV headers should be used in the display name of the
     * test.
     * <p>
     * If set to {@code true} and the first row contains headers, those headers
     * will be included in the display name of each test invocation.
     * </p>
     *
     * <p>Defaults to {@code false}.</p>
     *
     * @return whether to use headers in the test display name
     * @see CsvSource#useHeadersInDisplayName
     */
    boolean useHeadersInDisplayName() default false;

    /**
     * Specifies the character used for quoting CSV values.
     * <p>
     * Values enclosed in this character will be parsed as a single argument,
     * even if they contain the delimiter character.
     * </p>
     *
     * <p>Defaults to single quote (').</p>
     *
     * @return the quote character
     * @see CsvSource#quoteCharacter
     */
    char quoteCharacter() default '\'';

    /**
     * Specifies the character used to separate CSV values.
     * <p>
     * This is an alternative to using {@link #delimiterString} and cannot be
     * used in conjunction with {@link #delimiterString}
     * </p>
     *
     * <p>Defaults implicitly to {@code ','}.</p>
     *
     * @return the delimiter character
     * @see CsvSource#delimiter
     */
    char delimiter() default '\0';

    /**
     * Specifies the string used to separate CSV values.
     * <p>
     * This is an alternative to using {@link #delimiter} and cannot be used in
     * conjunction with {@link #delimiter}
     * </p>
     *
     * <p>Defaults implicitly to {@code ","}.</p>
     *
     * @return the delimiter string
     * @see CsvSource#delimiterString
     */
    String delimiterString() default "";

    /**
     * Specifies the string that should be interpreted as an empty value.
     *
     * <p>Defaults to {@code ""}.</p>
     *
     * @return the string representation of an empty value
     * @see CsvSource#emptyValue
     */
    String emptyValue() default "";

    /**
     * Specifies strings that should be interpreted as {@code null} values.
     *
     * <p>Defaults to {@code {}}.</p>
     *
     * @return an array of strings to be interpreted as {@code null}
     * @see CsvSource#nullValues
     */
    String[] nullValues() default { };

    /**
     * Specifies the maximum number of characters allowed per column.
     * <p>Must be a positive number.</p>
     *
     * <p>Defaults to {@code 4096}.</p>
     *
     * @return the maximum number of characters allowed per column
     * @see CsvSource#maxCharsPerColumn
     */
    int maxCharsPerColumn() default 4096;

    /**
     * Determines whether leading and trailing whitespace characters of unquoted
     * CSV columns should be ignored.
     *
     * <p>Defaults to {@code true}.</p>
     *
     * @return whether to ignore leading and trailing whitespace
     * @see CsvSource#ignoreLeadingAndTrailingWhitespace
     */
    boolean ignoreLeadingAndTrailingWhitespace() default true;

    /**
     * Factory for creating dynamic proxy instances of {@link CsvAutoSource}.
     * <p>
     * This utility class provides a way to programmatically create
     * {@link CsvAutoSource} annotation instances at runtime, which is useful
     * when extending the functionality of {@link CsvAutoArgumentsProvider}.
     * </p>
     *
     * @see CsvAutoArgumentsProvider#accept(CsvAutoSource)
     */
    class ProxyFactory {

        /**
         * Creates a dynamic proxy instance of {@link CsvAutoSource} with the
         * specified attributes.
         * <p>
         * This utility method enables programmatic creation of
         * {@link CsvAutoSource} annotation instances at runtime, which is
         * useful for extending functionality of
         * {@link CsvAutoArgumentsProvider}.
         * </p>
         *
         * @param value the array of CSV rows to use
         * @param textBlock the text block containing CSV values
         * @param useHeadersInDisplayName whether to use headers in display name
         * @param quoteCharacter the character for quoting CSV values
         * @param delimiter the character used to separate CSV values
         * @param delimiterString the string used to separate CSV values
         * @param emptyValue the string that represents an empty value
         * @param nullValues the array of strings to interpret as null
         * @param maxCharsPerColumn the maximum number of characters allowed per column
         * @param ignoreLeadingAndTrailingWhitespace whether to ignore whitespace
         * @return a proxy instance of the {@link CsvAutoSource} annotation
         * @see CsvAutoArgumentsProvider#accept(CsvAutoSource)
         */
        public static CsvAutoSource create(
            String[] value,
            String textBlock,
            boolean useHeadersInDisplayName,
            char quoteCharacter,
            char delimiter,
            String delimiterString,
            String emptyValue,
            String[] nullValues,
            int maxCharsPerColumn,
            boolean ignoreLeadingAndTrailingWhitespace
        ) {
            return (CsvAutoSource) Proxy.newProxyInstance(
                CsvAutoSource.class.getClassLoader(),
                new Class[] { CsvAutoSource.class },
                (proxy, method, args) -> {
                    switch (method.getName()) {
                        case "annotationType": return CsvAutoSource.class;
                        case "value": return value;
                        case "textBlock": return textBlock;
                        case "useHeadersInDisplayName": return useHeadersInDisplayName;
                        case "quoteCharacter": return quoteCharacter;
                        case "delimiter": return delimiter;
                        case "delimiterString": return delimiterString;
                        case "emptyValue": return emptyValue;
                        case "nullValues": return nullValues;
                        case "maxCharsPerColumn": return maxCharsPerColumn;
                        case "ignoreLeadingAndTrailingWhitespace":
                            return ignoreLeadingAndTrailingWhitespace;
                        default: return method.getDefaultValue();
                    }
                }
            );
        }
    }
}
